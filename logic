from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel
from agents.utils.rag_pipeline import build_rag_chain
from utils.functions import (
    insert_chat_history,
    get_chat_history,
    get_recent_sessions,
    get_top_sessions_latest_messages,
)

router = APIRouter()
rag_chain = build_rag_chain()

class ChatRequest(BaseModel):
    question: str
    session_id: str = None  # Optional for backward compatibility

class ChatResponse(BaseModel):
    answer: str

class ChatHistoryItem(BaseModel):
    id: int
    timestamp: str
    question: str
    answer: str

class SessionSummary(BaseModel):
    session_id: str
    last_time: str

class SessionLatestMessage(BaseModel):
    session_id: str
    id: int
    timestamp: str
    question: str
    answer: str

from agents.test import build_intent_classifier, build_entity_extractor, get_full_docs
import json
intent_classifier = build_intent_classifier()
entity_extractor = build_entity_extractor()

@router.post("/chat/", response_model=ChatResponse)
async def chat(request: ChatRequest):
    try:
        # 1) classify intent
        intent_resp = intent_classifier.invoke({"query": request.question})
        intent = getattr(intent_resp, "content", "none").strip().lower()

        # 2) if none -> quick RAG fallback
        if intent == "none":
            result = rag_chain.invoke({"input": request.question})
            answer = result["answer"]
            insert_chat_history(request.question, answer, request.session_id)
            return ChatResponse(answer=answer)

        # 3) extract entities (may contain lists)
        ent_resp = entity_extractor.invoke({"query": request.question})
        try:
            entities = json.loads(ent_resp.content)
        except Exception:
            entities = {"standard_names": [], "standard_versions": [], "release_date": None}

        standard_names = entities.get("standard_names", []) or []
        standard_versions = entities.get("standard_versions", []) or []

        # 4) build filters and collect all docs for each filter via get_full_docs
        all_docs = []  # list of (doc_text, metadata)
        if standard_names:
            for i, name in enumerate(standard_names):
                filters = {"standard_name": name}
                if i < len(standard_versions) and standard_versions[i]:
                    filters["standard_version"] = standard_versions[i]
                docs = get_full_docs(filters)
                all_docs.extend(docs)
        elif standard_versions:
            for v in standard_versions:
                filters = {"standard_version": v}
                docs = get_full_docs(filters)
                all_docs.extend(docs)

        # 5) if no docs found -> fallback to RAG
        if not all_docs:
            result = rag_chain.invoke({"input": request.question})
            answer = result["answer"]
            insert_chat_history(request.question, answer, request.session_id)
            return ChatResponse(answer=answer)

        # 6) build context from retrieved docs (limit chunks to avoid huge payload)
        MAX_CHUNKS = 20
        selected = all_docs[:MAX_CHUNKS]
        context = "\n\n".join([doc for doc, _meta in selected])

        # 7) ask RAG with structured prompt + context
        prompt_input = f"Intent: {intent}\n\nQuery: {request.question}\n\nContext:\n{context}"
        result = rag_chain.invoke({"input": prompt_input})
        answer = result["answer"]

        # 8) save history and return
        insert_chat_history(request.question, answer, request.session_id)
        return ChatResponse(answer=answer)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/chat-history/", response_model=list[ChatHistoryItem])
async def chat_history(session_id: str = Query(None)):
    """
    Get chat history for a session (or all if session_id is None).
    """
    rows = get_chat_history(session_id=session_id)
    return [
        ChatHistoryItem(
            id=row["id"],
            timestamp=row["timestamp"],
            question=row["question"],
            answer=row["answer"]
        )
        for row in rows
    ]

@router.get("/sessions/", response_model=list[SessionSummary])
async def sessions():
    """
    Get summaries of recent sessions.
    """
    sessions = get_recent_sessions()
    return [
        SessionSummary(session_id=s["session_id"], last_time=s["last_time"])
        for s in sessions
    ]

@router.get("/top-sessions-latest/", response_model=list[SessionLatestMessage])
async def top_sessions_latest():
    """
    Get the latest chat message from each of the top 3 latest sessions.
    """
    messages = get_top_sessions_latest_messages(limit=3)
    return [
        SessionLatestMessage(
            session_id=m["session_id"],
            id=m["id"],
            timestamp=m["timestamp"],
            question=m["question"],
            answer=m["answer"],
        )
        for m in messages
    ]
