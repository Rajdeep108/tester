@router.post("/api/ingest")
def ingest_file(req: IngestRequest):
    # --- Try direct match first ---
    validated_location = os.path.join(VALIDATED_DIR, req.filename)
    
    if not os.path.isfile(validated_location):
        # --- Fallback: search for renamed file ---
        matches = [
            f for f in os.listdir(VALIDATED_DIR)
            if f.startswith(os.path.splitext(req.filename)[0])
        ]
        if matches:
            validated_location = os.path.join(VALIDATED_DIR, matches[0])
        else:
            return {"success": False, "message": "File not found in validated docs."}

    # Extract content
    ext = os.path.splitext(validated_location)[1].lower()
    if ext == ".docx":
        content = read_docx(validated_location)
    elif ext == ".doc":
        content = read_doc(validated_location)
    else:
        content = ""

    # Extract standard metadata
    standard_match = STANDARD_REGEX.search(content)
    standard_name = standard_match.group(0).upper() if standard_match else "3GPP-UNKNOWN"

    version_match = VERSION_REGEX.search(content)
    version = version_match.group(0).upper() if version_match else "V0.0.0"

    release_date_match = DATE_REGEX.search(content)
    release_date = release_date_match.group(1) if release_date_match else None

    metadata = {
        "filename": os.path.basename(validated_location),
        "standard_name": standard_name,
        "standard_version": version,
        "release_date": release_date
    }

    # Ingest as before
    try:
        if already_ingested(standard_name, version, persist_dir=PATH_TO_VECTORSTORE):
            return {
                "success": False,
                "message": f"⚠️ Standard '{standard_name}' version '{version}' already exists in vector DB",
                "metadata": metadata,
                "skipped": True
            }
        else:
            ingest_text(content, metadata=metadata)
            return {
                "success": True,
                "message": "✅ Ingested successfully into vector DB",
                "metadata": metadata,
                "skipped": False
            }
    except Exception as e:
        return {
            "success": False,
            "message": f"❌ Error ingesting: {str(e)}",
            "metadata": metadata,
            "skipped": False
        }
