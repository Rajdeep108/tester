from langchain_chroma import Chroma

# existing...
PATH_TO_VECTORSTORE = r"C:\Users\342534\Desktop\Telecom Standards Management\backend\vectorstores"

def get_full_docs(filters: dict, intent: str = None):
    """
    Returns documents + metadata for given filters.
    If no filters and intent is 'analyze_latest' or 'compare_versions',
    gracefully fallback to latest standards.
    """
    vectordb = Chroma(
        collection_name="standards_collection",
        embedding_function=embeddings,
        persist_directory=PATH_TO_VECTORSTORE,
    )
    collection = vectordb._collection

    # --- normal flow: filters provided ---
    if filters:
        # Ensure $and operator for multiple metadata
        if len(filters) > 1:
            where = {"$and": [{k: v} for k, v in filters.items()]}
        else:
            where = filters
        results = collection.get(include=["documents", "metadatas"], where=where)
        docs = results.get("documents", [])
        metadatas = results.get("metadatas", [])
        return list(zip(docs, metadatas))

    # --- fallback flow: no filters ---
    results = collection.get(include=["documents", "metadatas"])
    docs = results.get("documents", [])
    metadatas = results.get("metadatas", [])

    if not docs or not metadatas:
        return []

    # analyze_latest â†’ return most recent doc
    if intent == "analyze_latest":
        sorted_items = sorted(
            zip(docs, metadatas),
            key=lambda x: x[1].get("release_date", ""),
            reverse=True
        )
        return [sorted_items[0]]

    # compare_versions â†’ return 2 most recent versions of same standard
    if intent == "compare_versions":
        grouped = {}
        for doc, meta in zip(docs, metadatas):
            name = meta.get("standard_name")
            if not name:
                continue
            grouped.setdefault(name, []).append((doc, meta))

        for name, items in grouped.items():
            if len(items) >= 2:
                items_sorted = sorted(
                    items, key=lambda x: x[1].get("release_date", ""), reverse=True
                )
                return items_sorted[:2]

    # default: return nothing
    return []
