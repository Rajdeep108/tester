from fastapi import APIRouter, Query
from pydantic import BaseModel
from agents.utils.rag_pipeline import build_rag_chain_and_retriever, evaluate_retrieval_accuracy
from utils.functions import (
    insert_chat_history,
    get_chat_history,
    get_recent_sessions,
    get_top_sessions_latest_messages,
    insert_agent_metrics,
    update_user_feedback,
    update_retrieval_accuracy,
    get_agent_metrics_averages,
)
import time
import logging
import traceback

router = APIRouter()

# Build chain and retriever
rag_chain, rag_retriever = build_rag_chain_and_retriever()

class ChatRequest(BaseModel):
    question: str
    session_id: str = None

class ChatResponse(BaseModel):
    answer: str
    chat_id: int

class ChatHistoryItem(BaseModel):
    id: int
    timestamp: str
    question: str
    answer: str

class SessionSummary(BaseModel):
    session_id: str
    last_time: str

class SessionLatestMessage(BaseModel):
    session_id: str
    id: int
    timestamp: str
    question: str
    answer: str

class FeedbackRequest(BaseModel):
    chat_id: int
    feedback: int  # 1=up, 0=down

class RetrievalAccuracyRequest(BaseModel):
    chat_id: int
    accuracy: float  # 0..100

class AgentMetricsResponse(BaseModel):
    user_satisfaction: float
    retrieval_accuracy: float
    latency: float

@router.post("/chat/", response_model=ChatResponse)
async def chat(request: ChatRequest):
    t0 = time.perf_counter()
    fallback_answer = "Sorry, I couldn't process your request. Please try again."
    try:
        # --- Fetch last 3 chats for session --- QnA pair... QA1 QA2 QA3
        history = []
        if request.session_id:
            rows = get_chat_history(session_id=request.session_id)
            # Ensure sorted by timestamp ascending (oldest â†’ newest)
            rows = sorted(rows, key=lambda x: x["timestamp"])
            # Take the last 3
            history = rows[-3:]

        # --- Build conversational context ---
        history_str = ""
        for row in history:
            history_str += f"User: {row['question']}\nAssistant: {row['answer']}\n"
        final_input = history_str + f"User: {request.question}\nAssistant:"

        # --- Run RAG ---
        result = rag_chain.invoke({"input": final_input})
        answer = result.get("answer", None)
        if not answer:
            raise ValueError("RAG pipeline did not return an answer.")

        # --- Retrieval still only on current question ---
        context_docs = rag_retriever.get_relevant_documents(request.question)
        context = "\n".join([doc.page_content for doc in context_docs])
        latency_ms = (time.perf_counter() - t0) * 1000

        # --- Save chat + metrics ---
        chat_id = insert_chat_history(request.question, answer, request.session_id)
        insert_agent_metrics(chat_id, request.session_id, latency_ms)

        accuracy = evaluate_retrieval_accuracy(request.question, answer, context)
        update_retrieval_accuracy(chat_id, accuracy)

        return ChatResponse(answer=answer, chat_id=chat_id)

    except Exception as e:
        logging.error("Exception in /chat/: %s", e)
        traceback.print_exc()
        try:
            latency_ms = (time.perf_counter() - t0) * 1000
            chat_id = insert_chat_history(request.question, fallback_answer, request.session_id)
            insert_agent_metrics(chat_id, request.session_id, latency_ms)
            update_retrieval_accuracy(chat_id, 0)
        except Exception as db_e:
            logging.error("Failed to save error chat/metrics: %s", db_e)
            traceback.print_exc()
            return ChatResponse(answer=fallback_answer, chat_id=-1)
        return ChatResponse(answer=fallback_answer, chat_id=chat_id)


@router.get("/chat-history/", response_model=list[ChatHistoryItem])
async def chat_history(session_id: str = Query(None)):
    rows = get_chat_history(session_id=session_id)
    return [
        ChatHistoryItem(
            id=row["id"],
            timestamp=row["timestamp"],
            question=row["question"],
            answer=row["answer"]
        )
        for row in rows
    ]

@router.post("/chat-feedback/")
async def chat_feedback(request: FeedbackRequest):
    success = update_user_feedback(request.chat_id, request.feedback)
    return {"status": "ok" if success else "error"}

@router.post("/chat-accuracy/")
async def chat_accuracy(request: RetrievalAccuracyRequest):
    update_retrieval_accuracy(request.chat_id, request.accuracy)
    return {"status": "ok"}

@router.get("/agent-metrics/", response_model=AgentMetricsResponse)
async def agent_metrics():
    metrics = get_agent_metrics_averages()
    print(f"[DEBUG] /agent-metrics/ response: {metrics}")
    return metrics

@router.get("/sessions/", response_model=list[SessionSummary])
async def sessions():
    sessions = get_recent_sessions()
    return [
        SessionSummary(session_id=s["session_id"], last_time=s["last_time"])
        for s in sessions
    ]

@router.get("/top-sessions-latest/", response_model=list[SessionLatestMessage])
async def top_sessions_latest():
    messages = get_top_sessions_latest_messages(limit=4)
    return [
        SessionLatestMessage(
            session_id=m["session_id"],
            id=m["id"],
            timestamp=m["timestamp"],
            question=m["question"],
            answer=m["answer"],
        )
        for m in messages
    ]
