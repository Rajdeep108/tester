@router.post("/api/validate")
def validate_file(req: ValidateRequest):
    file_location = os.path.join(UPLOAD_DIR, req.filename)
    if not os.path.isfile(file_location):
        return {"is_valid": False, "validation_message": "Not Found"}

    is_valid, validation_message = validate_document(file_location)

    if not is_valid:
        return {"is_valid": False, "validation_message": validation_message}

    # Move to validated folder
    validated_location = os.path.join(VALIDATED_DIR, req.filename)
    shutil.move(file_location, validated_location)

    # Extract metadata
    ext = os.path.splitext(validated_location)[1].lower()
    content = read_docx(validated_location) if ext == ".docx" else read_doc(validated_location)
    standard_match = STANDARD_REGEX.search(content)
    standard_name = standard_match.group(0).upper() if standard_match else "3GPP-UNKNOWN"
    version_match = VERSION_REGEX.search(content)
    version = version_match.group(0).upper() if version_match else "V0.0.0"
    metadata = {"filename": req.filename, "standard_name": standard_name, "standard_version": version}

    return {
        "is_valid": True,
        "validation_message": validation_message,
        "validated_location": validated_location,
        "metadata": metadata
    }

# --- Ingest Only ---
class IngestRequest(BaseModel):
    filename: str
    metadata: dict

@router.post("/api/ingest")
def ingest_file(req: IngestRequest):
    validated_location = os.path.join(VALIDATED_DIR, req.filename)
    if not os.path.isfile(validated_location):
        return {"ingested": False, "message": "Validated file not found."}

    ext = os.path.splitext(validated_location)[1].lower()
    content = read_docx(validated_location) if ext == ".docx" else read_doc(validated_location)

    try:
        if already_ingested(req.metadata["standard_name"], req.metadata["standard_version"], persist_dir=PATH_TO_VECTORSTORE):
            return {"ingested": False, "message": "Already in vector DB (skipped)."}
        ingest_text(content, metadata=req.metadata)
        return {"ingested": True, "message": "Ingested successfully."}
    except Exception as e:
        return {"ingested": False, "message": f"Ingestion error: {str(e)}"}
